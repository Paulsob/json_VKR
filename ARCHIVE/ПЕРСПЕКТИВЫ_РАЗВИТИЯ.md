# ПЕРСПЕКТИВЫ РАЗВИТИЯ ПРОЕКТА ПЛАНИРОВЩИКА СМЕН ВОДИТЕЛЕЙ

## 1. ФУНКЦИОНАЛ СОЗДАНИЯ ГРАФИКА ОТПУСКОВ

### Актуальность и цели

**Текущая ситуация:**
- Отпуска вводятся вручную через форму отсутствий (`absence.js`)
- Нет автоматического планирования отпусков на год/полгода
- Нет контроля баланса отпускных дней
- Нет предотвращения конфликтов при планировании отпусков нескольких водителей одновременно
- Нет учета производственной необходимости и сезонности

**Цели внедрения:**
1. **Автоматизация планирования отпусков** - создание графика на год с учетом требований ТК РФ
2. **Оптимизация распределения** - равномерное распределение отпусков в течение года
3. **Предотвращение конфликтов** - автоматический контроль минимального количества водителей на линии
4. **Интеграция с планировщиком смен** - автоматическое исключение водителей в отпуске из расписания
5. **Учет баланса отпускных дней** - контроль остатков и планирование использования

### Функциональные возможности

**Основной функционал:**
- Календарь отпусков с визуализацией периодов для каждого водителя
- Автоматическое распределение отпусков по принципу справедливости (ротация)
- Ручная корректировка графика с проверкой ограничений
- Уведомления водителям о запланированных отпусках
- Экспорт графика в Excel/PDF для кадровой службы
- Расчет остатка отпускных дней для каждого водителя
- Учет переноса отпусков на следующий год

**Дополнительные возможности:**
- Предпочтения водителей (пожелания по датам)
- Блокировка определенных периодов (высокий сезон, праздники)
- Групповые отпуска (семейные обстоятельства)
- История отпусков и статистика

### Техническая реализация

**Модель данных:**
```python
# Таблица vacations (отпуска)
- id, driver_id, start_date, end_date, days_count
- vacation_type (основной/дополнительный/без сохранения)
- status (запланирован/утвержден/использован/отменен)
- approval_date, approved_by
- notes

# Таблица vacation_balance (баланс отпусков)
- driver_id, year, total_days, used_days, remaining_days
- carried_over (перенесено с прошлого года)
```

**Алгоритм планирования:**
1. Расчет оптимального распределения отпусков по месяцам
2. Учет минимального количества водителей на линии
3. Применение правил справедливости (кто давно не был в отпуске)
4. Учет пожеланий водителей при возможности
5. Генерация предварительного графика
6. Валидация на конфликты и нехватку ресурсов

**Интеграция с существующим кодом:**
- Модификация `_load_absent_drivers_for_day_shift()` для автоматической проверки отпусков
- Расширение API `/submit-absence` для работы с отпусками
- Новые endpoints: `/api/vacations`, `/api/vacation-schedule`, `/api/vacation-balance`

### Преимущества

**Для диспетчеров:**
- Сокращение времени на планирование отпусков с недель до часов
- Автоматический контроль соблюдения норм
- Визуализация графика для быстрого анализа
- Предотвращение ошибок и конфликтов

**Для водителей:**
- Прозрачность планирования отпусков
- Возможность внести пожелания
- Своевременные уведомления о датах отпуска
- Доступ к информации о балансе отпускных дней

**Для организации:**
- Соблюдение трудового законодательства
- Оптимизация использования ресурсов
- Снижение рисков нехватки водителей
- Улучшение удовлетворенности персонала

### План реализации

**Этап 1 (2-3 недели): Базовая модель данных и CRUD**
- Создание таблиц в БД для отпусков
- API для создания/редактирования/удаления отпусков
- Валидация дат и конфликтов
- Интеграция с текущей системой отсутствий

**Этап 2 (2-3 недели): Автоматическое планирование**
- Алгоритм распределения отпусков
- Учет ограничений и требований
- Генерация предварительного графика
- Интерфейс для просмотра и корректировки

**Этап 3 (1-2 недели): UI и отчетность**
- Календарный интерфейс для графика отпусков
- Форма для пожеланий водителей
- Экспорт графиков в различные форматы
- Дашборд со статистикой

---

## 2. ДОБАВЛЕНИЕ БАЗЫ ДАННЫХ К ПРОЕКТУ

### Актуальность и цели

**Текущая ситуация:**
- Данные хранятся в JSON файлах (`history_*.json`, `real_absences.json`)
- Excel файлы как основной источник данных
- Нет целостности данных и транзакций
- Сложность масштабирования и параллельной работы
- Нет индексов для быстрого поиска
- Риск потери данных при сбоях
- Сложность резервного копирования и восстановления

**Цели внедрения:**
1. **Целостность данных** - гарантия консистентности через ACID-транзакции
2. **Производительность** - индексы и оптимизация запросов
3. **Масштабируемость** - поддержка больших объемов данных
4. **Надежность** - транзакции, логирование, резервное копирование
5. **Безопасность** - контроль доступа на уровне БД
6. **Аналитика** - SQL-запросы для сложных отчетов

### Архитектура базы данных

**Выбор СУБД:**
- **PostgreSQL** (рекомендуется для production) - полнофункциональная, надежная
- **SQLite** (для начала/разработки) - легковесная, без отдельного сервера

**Основные таблицы:**

```sql
-- Водители
CREATE TABLE drivers (
    id SERIAL PRIMARY KEY,
    tab_no VARCHAR(20) UNIQUE NOT NULL,
    full_name VARCHAR(255),
    graph_type VARCHAR(50),
    hire_date DATE,
    status VARCHAR(20) DEFAULT 'active', -- active, inactive, fired
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);

-- Маршруты
CREATE TABLE routes (
    id SERIAL PRIMARY KEY,
    route_number INTEGER UNIQUE NOT NULL,
    name VARCHAR(255),
    description TEXT,
    is_active BOOLEAN DEFAULT TRUE
);

-- Расписания маршрутов
CREATE TABLE route_schedules (
    id SERIAL PRIMARY KEY,
    route_id INTEGER REFERENCES routes(id),
    is_weekend BOOLEAN NOT NULL,
    excel_sheet_name VARCHAR(255),
    start_time TIME,
    end_time TIME,
    route_number INTEGER, -- для обратной совместимости
    created_at TIMESTAMP DEFAULT NOW()
);

-- История работы водителей (замена JSON файлов)
CREATE TABLE driver_history (
    id SERIAL PRIMARY KEY,
    driver_id INTEGER REFERENCES drivers(id),
    work_date DATE NOT NULL,
    shift_code INTEGER NOT NULL, -- 1 или 2
    start_time TIME NOT NULL,
    end_time TIME NOT NULL,
    start_dt TIMESTAMP,
    end_dt TIMESTAMP,
    duration_hours DECIMAL(4,2),
    is_next_day BOOLEAN DEFAULT FALSE,
    route_id INTEGER REFERENCES routes(id),
    note TEXT, -- 'РЕЗЕРВ', 'ОСНОВНАЯ СМЕНА'
    weekend_extra BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP DEFAULT NOW(),
    INDEX idx_driver_date (driver_id, work_date),
    INDEX idx_date (work_date)
);

-- Отсутствия водителей
CREATE TABLE absences (
    id SERIAL PRIMARY KEY,
    driver_id INTEGER REFERENCES drivers(id),
    absence_date DATE NOT NULL,
    shift_code INTEGER, -- 1, 2 или NULL (весь день)
    reason VARCHAR(50) NOT NULL, -- 'vacation', 'sick', 'no_notice', 'other'
    reason_code INTEGER, -- для обратной совместимости: 0, 1, 2
    description TEXT,
    created_by INTEGER, -- user_id
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW(),
    INDEX idx_driver_date (driver_id, absence_date)
);

-- Сформированные расписания
CREATE TABLE schedules (
    id SERIAL PRIMARY KEY,
    schedule_date DATE NOT NULL,
    route_id INTEGER REFERENCES routes(id),
    excel_file_path VARCHAR(500),
    status VARCHAR(50) DEFAULT 'draft', -- draft, approved, published
    created_at TIMESTAMP DEFAULT NOW(),
    approved_at TIMESTAMP,
    approved_by INTEGER, -- user_id
    INDEX idx_date_route (schedule_date, route_id)
);

-- Назначения водителей на смены
CREATE TABLE schedule_assignments (
    id SERIAL PRIMARY KEY,
    schedule_id INTEGER REFERENCES schedules(id),
    driver_id INTEGER REFERENCES drivers(id),
    slot_row INTEGER, -- номер строки в Excel
    shift_code INTEGER NOT NULL,
    assignment_status VARCHAR(50) DEFAULT 'assigned', -- assigned, no_reserve, cancelled
    created_at TIMESTAMP DEFAULT NOW()
);
```

### Миграция данных

**План миграции:**

1. **Создание структуры БД** (SQLAlchemy ORM)
   - Определение моделей для всех таблиц
   - Миграции через Alembic
   - Индексы и внешние ключи

2. **Импорт водителей из Excel**
   - Парсинг листа "Весь_табель"
   - Создание записей в таблице `drivers`

3. **Миграция истории работы**
   - Чтение всех `history_*.json` файлов
   - Преобразование в записи `driver_history`
   - Валидация данных

4. **Миграция отсутствий**
   - Импорт из `real_absences.json`
   - Связывание с водителями по табельному номеру

5. **Обратная совместимость**
   - Сохранение возможности экспорта в JSON для совместимости
   - Параллельная работа со старым и новым форматом на период миграции

### Техническая реализация

**Используемые технологии:**
- **SQLAlchemy** - ORM для работы с БД
- **Alembic** - миграции схемы БД
- **Psycopg2** - драйвер для PostgreSQL
- **Flask-SQLAlchemy** - интеграция с Flask

**Структура кода:**
```
structure_model/
├── models/
│   ├── __init__.py
│   ├── driver.py          # Модель Driver
│   ├── route.py           # Модель Route
│   ├── schedule.py        # Модель Schedule
│   └── history.py         # Модель DriverHistory
├── database/
│   ├── __init__.py        # Инициализация БД
│   ├── migrations/        # Alembic миграции
│   └── seed_data.py       # Начальные данные
└── services/
    ├── driver_service.py  # Бизнес-логика для водителей
    └── schedule_service.py # Бизнес-логика для расписаний
```

### Преимущества

**Производительность:**
- Быстрый поиск по индексам (вместо чтения всех JSON файлов)
- Оптимизированные запросы через SQL
- Кэширование часто используемых данных

**Надежность:**
- Транзакции гарантируют целостность данных
- Автоматическое логирование изменений
- Резервное копирование стандартными средствами СУБД

**Масштабируемость:**
- Поддержка миллионов записей
- Возможность репликации для высокой доступности
- Горизонтальное масштабирование (sharding)

**Безопасность:**
- Контроль доступа через права пользователей БД
- Защита от SQL-инъекций через ORM
- Аудит изменений данных

### План реализации

**Этап 1 (2-3 недели): Настройка БД и модели**
- Установка и настройка PostgreSQL/SQLite
- Создание моделей SQLAlchemy
- Настройка миграций Alembic
- Базовые CRUD операции

**Этап 2 (2-3 недели): Миграция данных**
- Скрипты импорта из JSON и Excel
- Валидация и очистка данных
- Тестирование целостности данных
- Обратная совместимость

**Этап 3 (2-3 недели): Рефакторинг кода**
- Замена работы с JSON на работу с БД
- Обновление всех модулей (driver_scheduler, server, etc.)
- Оптимизация запросов
- Тестирование функциональности

**Этап 4 (1 неделя): Документация и деплой**
- Документация API и схемы БД
- Настройка резервного копирования
- Развертывание на production
- Мониторинг производительности

---

## 3. ТЕСТИРОВАНИЕ МОДЕЛИ

### Актуальность и цели

**Текущая ситуация:**
- Отсутствуют автоматические тесты
- Нет гарантии корректности работы после изменений
- Сложность рефакторинга без риска сломать функциональность
- Нет документации ожидаемого поведения через тесты
- Сложность отладки проблем в production

**Цели внедрения:**
1. **Надежность** - гарантия корректной работы после изменений
2. **Качество кода** - выявление багов на ранних этапах
3. **Документация** - тесты как спецификация поведения
4. **Рефакторинг** - безопасное улучшение кода
5. **Регрессионное тестирование** - предотвращение повторения багов
6. **CI/CD** - автоматическая проверка при коммитах

### Типы тестов

**1. Unit-тесты (модульные тесты)**

**Цель:** Тестирование отдельных функций и методов изолированно

**Примеры тестируемых модулей:**

```python
# tests/unit/test_driver_scheduler.py

def test_get_rest_hours_for_driver():
    """Тест расчета часов отдыха между сменами"""
    # Подготовка тестовых данных
    history_data = {
        "105": {
            "end_str": "23:00",
            "is_next_day": False,
            "shift_code": 2
        }
    }
    target_start = datetime(2024, 1, 15, 7, 0)  # 7:00 следующего дня
    
    # Выполнение
    rest_hours = get_rest_hours_for_driver("105", history_data, target_start)
    
    # Проверка
    assert rest_hours == 8.0  # От 23:00 до 7:00 = 8 часов

def test_choose_driver_for_slot():
    """Тест выбора водителя для смены"""
    candidates = ["105", "106", "107"]
    history_data = {
        "105": {"end_str": "23:00", "is_next_day": False},
        "106": {"end_str": "20:00", "is_next_day": False},  # Больше отдыха
        "107": {"end_str": "22:00", "is_next_day": False}
    }
    target_start = datetime(2024, 1, 15, 7, 0)
    
    chosen = choose_driver_for_slot(candidates, history_data, target_start, 1, set())
    
    # Должен выбрать водителя с наибольшим отдыхом (>= REST_HOURS)
    assert chosen in ["106"]

def test_worked_same_shift_yesterday():
    """Тест проверки работы в той же смене вчера"""
    history_data = {
        "105": {"shift_code": 1}
    }
    
    # Водитель работал 1 смену вчера
    assert worked_same_shift_yesterday("105", history_data, 1) == True
    assert worked_same_shift_yesterday("105", history_data, 2) == False
    assert worked_same_shift_yesterday("106", history_data, 1) == False  # Нет в истории
```

**2. Integration-тесты (интеграционные тесты)**

**Цель:** Тестирование взаимодействия между модулями

```python
# tests/integration/test_schedule_flow.py

def test_full_schedule_generation():
    """Тест полного цикла создания расписания"""
    # Подготовка
    test_day = 15
    prev_day = 14
    route_number = 55
    
    # Создание тестовых данных в БД/фикстурах
    create_test_drivers()
    create_test_schedule_data()
    
    # Выполнение
    run_planner(test_day, prev_day, route_number)
    
    # Проверка результата
    schedule_file = f"output/Расписание_Итог_{test_day}.xlsx"
    assert os.path.exists(schedule_file)
    
    # Проверка содержимого
    wb = load_workbook(schedule_file)
    ws = wb["Расписание_рабочего_дня_55"]
    
    # Проверка что все слоты заполнены
    assert ws.cell(row=5, column=COL_SHIFT_1_INSERT).value is not None
    
    # Проверка что водители не назначены дважды
    assigned_drivers = get_all_assigned_drivers(ws)
    assert len(assigned_drivers) == len(set(assigned_drivers))

def test_absence_handling():
    """Тест обработки отсутствующих водителей"""
    # Создание отсутствия
    create_absence(driver_id="105", day=15, shift=1, reason="vacation")
    
    # Генерация расписания
    run_planner(15, 14, 55)
    
    # Проверка что отсутствующий не назначен
    schedule = load_schedule(15)
    assert "105" not in schedule.get_all_assigned_drivers()
```

**3. API-тесты**

**Цель:** Тестирование веб-API endpoints

```python
# tests/api/test_api_endpoints.py

def test_submit_absence_api(client):
    """Тест API создания отсутствия"""
    response = client.post('/submit-absence', json={
        'tab_no': '105',
        'shift': 1,
        'day': 15,
        'reason': 0  # Отпуск
    })
    
    assert response.status_code == 200
    assert response.json['success'] == True
    
    # Проверка что отсутствие сохранено
    absences = load_absences()
    assert any(a['tab_no'] == '105' and a['day'] == 15 for a in absences)

def test_api_schedule_endpoint(client):
    """Тест API получения расписания"""
    # Создание тестового расписания
    create_test_schedule(day=15, route=55)
    
    response = client.get('/api/schedule/15?route=55')
    
    assert response.status_code == 200
    data = response.json
    assert data['success'] == True
    assert data['day'] == 15
    assert data['route'] == '55'
    assert 'rows' in data
    assert 'drivers' in data
```

**4. E2E тесты (end-to-end)**

**Цель:** Тестирование полного пользовательского сценария

```python
# tests/e2e/test_user_scenarios.py

def test_full_workflow():
    """Тест полного рабочего процесса"""
    # 1. Пользователь заходит на страницу
    driver = webdriver.Chrome()
    driver.get('http://localhost:5000')
    
    # 2. Просматривает календарь
    calendar = driver.find_element(By.ID, 'calendar-container')
    assert calendar is not None
    
    # 3. Добавляет отсутствие
    absence_button = driver.find_element(By.ID, 'absenceModal')
    absence_button.click()
    
    # Заполнение формы
    driver.find_element(By.NAME, 'tab_no').send_keys('105')
    driver.find_element(By.NAME, 'day').send_keys('15')
    driver.find_element(By.NAME, 'shift').send_keys('1')
    driver.find_element(By.NAME, 'reason').send_keys('0')
    
    # Отправка
    driver.find_element(By.XPATH, '//button[@type="submit"]').click()
    
    # 4. Просматривает расписание
    schedule_btn = driver.find_element(By.XPATH, '//button[contains(@class, "schedule-btn")]')
    schedule_btn.click()
    
    # Проверка отображения расписания
    schedule_display = driver.find_element(By.ID, 'scheduleDisplay')
    assert 'Расписание' in schedule_display.text
```

### Тестовые данные и фикстуры

**Создание тестовых данных:**

```python
# tests/fixtures/test_data.py

@pytest.fixture
def sample_drivers():
    """Фикстура с тестовыми водителями"""
    return [
        {"tab_no": "105", "graph_type": "5/2"},
        {"tab_no": "106", "graph_type": "2/2"},
        {"tab_no": "107", "graph_type": "5/2"}
    ]

@pytest.fixture
def sample_history():
    """Фикстура с тестовой историей"""
    return {
        "105": {
            "start_dt": datetime(2024, 1, 14, 7, 0),
            "end_dt": datetime(2024, 1, 14, 19, 0),
            "start_str": "07:00",
            "end_str": "19:00",
            "duration": 12.0,
            "shift_code": 1,
            "is_next_day": False
        }
    }

@pytest.fixture
def sample_schedule_slots():
    """Фикстура со слотами расписания"""
    return [
        {
            "excel_row": 5,
            "time_info": {
                "start_dt": datetime(2024, 1, 15, 7, 0),
                "end_dt": datetime(2024, 1, 15, 19, 0),
                "start_str": "07:00",
                "end_str": "19:00",
                "duration": 12.0
            }
        }
    ]
```

### Метрики покрытия

**Цели покрытия:**
- Unit-тесты: 80-90% покрытия кода
- Интеграционные тесты: 100% критичных путей
- API-тесты: все endpoints
- E2E тесты: основные пользовательские сценарии

**Инструменты:**
- `pytest-cov` - измерение покрытия кода
- `coverage.py` - генерация отчетов
- `pytest-xdist` - параллельный запуск тестов

### Преимущества

**Для разработки:**
- Быстрое обнаружение багов
- Уверенность при рефакторинге
- Документация поведения через тесты
- Упрощение отладки

**Для качества:**
- Гарантия работоспособности после изменений
- Предотвращение регрессий
- Выявление проблем на ранних этапах
- Соответствие требованиям

**Для процесса:**
- Автоматизация проверок
- Интеграция в CI/CD
- Сокращение времени на ручное тестирование
- Улучшение процессов разработки

### План реализации

**Этап 1 (1-2 недели): Настройка инфраструктуры**
- Установка pytest и зависимостей
- Настройка структуры тестов
- Создание фикстур и тестовых данных
- Настройка CI/CD для автоматического запуска

**Этап 2 (2-3 недели): Unit-тесты**
- Тесты для всех функций планировщика
- Тесты для обработки данных
- Тесты для утилит
- Достижение 80% покрытия

**Этап 3 (2-3 недели): Интеграционные и API тесты**
- Тесты взаимодействия модулей
- Тесты всех API endpoints
- Тесты сценариев использования
- Мокирование внешних зависимостей

**Этап 4 (1-2 недели): E2E тесты**
- Настройка Selenium/Playwright
- Тесты критичных пользовательских сценариев
- Автоматизация в CI/CD
- Документация запуска тестов

---

## 4. УВЕЛИЧЕНИЕ ЧИСЛА ТРАНСПОРТНЫХ СРЕДСТВ

### Актуальность и цели

**Текущая ситуация:**
- Система поддерживает только 2 маршрута (9 и 55)
- Жестко закодированные параметры маршрутов в конфиге
- Ограниченная масштабируемость архитектуры
- Сложность добавления новых маршрутов требует изменения кода

**Цели расширения:**
1. **Масштабируемость** - поддержка произвольного количества маршрутов
2. **Гибкость** - добавление новых маршрутов без изменения кода
3. **Универсальность** - поддержка разных типов транспорта (трамваи, автобусы, троллейбусы)
4. **Оптимизация** - планирование с учетом всех маршрутов одновременно
5. **Централизация** - единая система для всего парка

### Архитектурные изменения

**1. Универсальная модель маршрутов**

```python
# models/route.py

class Route(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    route_number = db.Column(db.Integer, unique=True, nullable=False)
    name = db.Column(db.String(255))
    transport_type = db.Column(db.String(50))  # 'tram', 'bus', 'trolleybus'
    is_active = db.Column(db.Boolean, default=True)
    
    # Расписания для разных дней недели
    weekday_schedule_sheet = db.Column(db.String(255))
    weekend_schedule_sheet = db.Column(db.String(255))
    
    # Параметры планирования
    rest_hours_required = db.Column(db.Float, default=12.0)
    allow_weekend_extra = db.Column(db.Boolean, default=False)
    
    # Водители, которые могут работать на маршруте
    drivers = db.relationship('RouteDriver', backref='route')
    
    created_at = db.Column(db.DateTime, default=datetime.utcnow)

class RouteDriver(db.Model):
    """Связь водителя с маршрутами, на которых он может работать"""
    id = db.Column(db.Integer, primary_key=True)
    route_id = db.Column(db.Integer, db.ForeignKey('route.id'))
    driver_id = db.Column(db.Integer, db.ForeignKey('driver.id'))
    priority = db.Column(db.Integer, default=0)  # Приоритет водителя на маршруте
    is_certified = db.Column(db.Boolean, default=True)
```

**2. Динамическая конфигурация**

Вместо жестко закодированного словаря `SCHEDULE_SHEETS`:

```python
# services/route_service.py

def get_schedule_sheet(route_number, is_weekend):
    """Динамическое получение листа расписания из БД"""
    route = Route.query.filter_by(
        route_number=route_number,
        is_active=True
    ).first()
    
    if not route:
        raise ValueError(f"Маршрут {route_number} не найден")
    
    return route.weekend_schedule_sheet if is_weekend else route.weekday_schedule_sheet

def get_route_config(route_number):
    """Получение конфигурации маршрута"""
    route = Route.query.filter_by(route_number=route_number).first()
    return {
        'rest_hours': route.rest_hours_required,
        'allow_weekend_extra': route.allow_weekend_extra,
        'transport_type': route.transport_type
    }
```

**3. Универсальный планировщик**

```python
# driver_scheduler.py (обновленная версия)

def run_planner_multi_route(target_day, prev_day, route_numbers=None):
    """
    Планировщик для нескольких маршрутов одновременно
    
    Args:
        target_day: День планирования
        prev_day: Предыдущий день для истории
        route_numbers: Список номеров маршрутов (None = все активные)
    """
    if route_numbers is None:
        # Получаем все активные маршруты из БД
        routes = Route.query.filter_by(is_active=True).all()
        route_numbers = [r.route_number for r in routes]
    
    # Общая история для всех маршрутов
    global_history = load_history(prev_day)
    
    # Планирование для каждого маршрута
    for route_number in route_numbers:
        route_config = get_route_config(route_number)
        route_history = filter_history_by_route(global_history, route_number)
        
        run_planner_single_route(
            target_day, 
            prev_day, 
            route_number,
            route_config,
            route_history
        )
    
    # Оптимизация между маршрутами (перераспределение водителей)
    optimize_cross_route_assignments(target_day, route_numbers)
```

**4. Кросс-маршрутная оптимизация**

```python
# optimizer/multi_route_optimizer.py

def optimize_cross_route_assignments(target_day, route_numbers):
    """
    Оптимизация назначений между маршрутами
    
    Цели:
    - Минимизировать нехватку водителей
    - Оптимизировать использование ресурсов
    - Учитывать квалификацию водителей на разных маршрутах
    """
    # Анализ загрузки по маршрутам
    route_loads = analyze_route_loads(target_day, route_numbers)
    
    # Поиск возможностей перераспределения
    for route1, route2 in combinations(route_numbers, 2):
        # Если на route1 нехватка, а на route2 избыток
        if route_loads[route1]['shortage'] > 0 and route_loads[route2]['surplus'] > 0:
            # Попытка перераспределения
            redistribute_drivers(
                target_day,
                from_route=route2,
                to_route=route1,
                count=min(route_loads[route1]['shortage'], route_loads[route2]['surplus'])
            )
```

### Функциональные возможности

**1. Управление маршрутами через UI**

- **Список маршрутов** - таблица со всеми маршрутами и их статусом
- **Добавление маршрута** - форма с полями:
  - Номер маршрута
  - Название
  - Тип транспорта
  - Листы Excel с расписаниями
  - Параметры планирования
- **Редактирование маршрута** - изменение параметров
- **Деактивация маршрута** - временное отключение без удаления

**2. Планирование для всех маршрутов**

- **Единое расписание** - планирование всех маршрутов одним запуском
- **Приоритизация маршрутов** - настройка важности маршрутов
- **Оптимизация ресурсов** - перераспределение водителей между маршрутами
- **Анализ загрузки** - визуализация распределения водителей

**3. Квалификация водителей**

- **Привязка водителей к маршрутам** - какие водители могут работать на каких маршрутах
- **Уровни квалификации** - базовый, продвинутый, инструктор
- **Обучение и сертификация** - учет обучения водителей новым маршрутам
- **Автоматическая проверка** - планировщик учитывает только сертифицированных водителей

**4. Масштабируемая архитектура**

```python
# Структура для множественных маршрутов

class MultiRoutePlanner:
    """Планировщик для работы с несколькими маршрутами"""
    
    def __init__(self, route_numbers=None):
        self.routes = self._load_routes(route_numbers)
        self.optimizer = CrossRouteOptimizer()
    
    def plan_day(self, target_day, prev_day):
        """Планирование для всех маршрутов"""
        # 1. Получение общих данных
        global_candidates = self._get_all_candidates(target_day)
        global_history = load_history(prev_day)
        
        # 2. Планирование по маршрутам
        assignments = {}
        for route in self.routes:
            route_assignments = self._plan_route(
                route, target_day, global_candidates, global_history
            )
            assignments[route.route_number] = route_assignments
        
        # 3. Оптимизация между маршрутами
        optimized = self.optimizer.optimize(assignments, global_candidates)
        
        # 4. Сохранение результатов
        self._save_assignments(target_day, optimized)
        
        return optimized
```

### Технические детали

**Производительность при масштабировании:**

1. **Параллельная обработка**
   - Использование multiprocessing для планирования разных маршрутов
   - Асинхронная обработка через Celery для фоновых задач

2. **Кэширование**
   - Кэш расписаний маршрутов
   - Кэш доступных водителей
   - Redis для распределенного кэширования

3. **Оптимизация запросов**
   - Batch-запросы к БД
   - Индексы на часто используемые поля
   - Материализованные представления для отчетов

**Ограничения и проверки:**

- Максимальное количество активных маршрутов
- Минимальное количество водителей на маршруте
- Проверка квалификации перед назначением
- Валидация доступности водителей на маршрутах

### Преимущества

**Для организации:**
- Единая система для всего парка
- Централизованное управление ресурсами
- Оптимизация использования водителей
- Масштабируемость на новые маршруты

**Для диспетчеров:**
- Удобное управление всеми маршрутами
- Визуализация общей картины
- Автоматизация рутинных задач
- Гибкость в настройке

**Для водителей:**
- Возможность работы на разных маршрутах
- Прозрачность распределения
- Учет квалификации и предпочтений

### План реализации

**Этап 1 (2-3 недели): Модель данных**
- Создание таблиц Route и RouteDriver
- Миграция существующих данных
- API для управления маршрутами
- Валидация данных

**Этап 2 (2-3 недели): Рефакторинг планировщика**
- Универсализация функций планирования
- Поддержка динамической конфигурации
- Обновление всех модулей
- Обратная совместимость

**Этап 3 (2-3 недели): UI и функционал**
- Интерфейс управления маршрутами
- Планирование для всех маршрутов
- Визуализация распределения
- Тестирование на реальных данных

**Этап 4 (2-3 недели): Оптимизация и масштабирование**
- Кросс-маршрутная оптимизация
- Производительность и кэширование
- Нагрузочное тестирование
- Документация и обучение

---

## ОБЩАЯ ОЦЕНКА ПЕРСПЕКТИВ

### Приоритеты реализации

1. **Высокий приоритет:**
   - База данных (фундамент для всего остального)
   - Тестирование модели (гарантия качества)
   
2. **Средний приоритет:**
   - Увеличение числа транспортных средств (масштабирование)
   
3. **Нижний приоритет:**
   - График отпусков (дополнительный функционал)

### Взаимосвязь направлений

- **БД** является основой для всех остальных улучшений
- **Тестирование** необходимо для безопасного развития
- **Масштабирование** требует надежной БД и тестов
- **График отпусков** логично реализовывать после БД

### Ожидаемые результаты

После реализации всех направлений:
- **Надежная система** с гарантией качества
- **Масштабируемое решение** для любого количества маршрутов
- **Автоматизация** всех аспектов планирования
- **Профессиональный продукт** готовый к коммерческому использованию

---

*Документ создан: 2024*




